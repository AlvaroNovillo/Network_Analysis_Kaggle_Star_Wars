---
title: "Netwok Analysis Project"
subtitle: "The Star Wars social netowrk"
author: "Eloy Pérez Gómez, Álvaro Novillo Correas & Jorge Sánchez Polo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(jsonlite)
library(igraph)
library(openxlsx)
library(chorddiag)
library(igraph)
library(tidyr)
library(ggplot2)
library(dplyr)
library(scales)
```


**1) Explain the network including which vertices and edges form it, as well as any additional attributes that may form the network, its vertices and/or its edges.**

We are going to study a Star Wars social network (this network was downloaded from kaggle at <https://www.kaggle.com/datasets/ruchi798/star-wars>). The nodes of this network are the characters of the first seven films and they are connected if they speak with each other in the same scene (this corresponds to the file "starwars-full-interactions-allCharacters-merged.json" from the downloaded data). 

The original network has the following elements:

- The nodes have the following properties:

  - name: Name of the character
  - value: Number of scenes the character appeared in
  - colour: Color in the visualization

- Links represent connections between characters:

  - source: zero-based index of the character that is one end of the link, the order of nodes is the order in which they are listed in the “nodes” element
  - target: zero-based index of the character that is the the other end of the link.
  - value: Number of scenes where the “source character” and “target character” of the link appeared together.

We modify this network and add the following attributes:

- name.real: Contains the name of each character (a copy of the previous attribute "name").
- name: a zero-based index for each character.
- colour: we have modified the color of some of the characters.
- role: we introdue anew attribute that separates the characters in main villains (letter "v"), heroes (letter "h") or background characters (letter "b").

```{r}
# Set the directory path where the JSON files are located
directory_path <- "data" #CHANGE IT WITH YOUR DATA PATH
# Get the list of all JSON files in the directory
json_files <- list.files(path = directory_path, pattern = "*.json", full.names = TRUE)
# Choose the desired JSON file
desired_file <- json_files[22]
# Load the JSON file into R
json_data <- fromJSON(desired_file)
```

Access the nodes and edges (the "nodes.xlsx" file contains the modified version of the nodes)
```{r}
nodes <- read.xlsx("nodes.xlsx")
edges <- json_data$links
```

**2) Describe what the analysis of such a network may be of interest. That is, what are the points that make the network of interest to a general audience.**

Star wars is a franchise most of us grew up watching, either the original trilogy or the later releases. The study of a social network composed of the Star wars characters and their relations may not be as important as some networks related with medicine applications or industry, but it is worth taking a look at, even if it is just for the sake of our childhood memories. 

**3) Make a first graph of the network and describe the main characteristics including whether the network is directed or undirected, if there are subnetworks that may be of interest, if there are loops and/or multi-edges, etc.**

Create a graph from the data
```{r}
network <- graph_from_data_frame(edges, vertices = nodes, directed = FALSE)
E(network)$weight <- edges$value
```

```{r}
# Set the color of each node
V(network)$color <- nodes$colour
# Set the label of each node
V(network)$label <- nodes$name
# Set role attribute of each node
V(network)$role <- nodes$role
V(network)$name = nodes$name.real
```

Plot the graph
```{r}
A = as_adjacency_matrix(network, attr="weight")
plot(network)
```

We have an undirected, weighted network. There are not any loops or multi-edges.

We have several interesting subnetworks. We are going to divide the network in two ways: first using the attributes of the nodes, i.e., considering the most relevant nodes in terms of weights and number of appearances; the second method for obtaining subnetworks is going to be using the information we have from the films. We are going to separate in a network for "heroes" and a network for "villains".

We are going to define three subnetworks depending on the weight of the characters and two subnetworks that contain the main villains and the heroes.

```{r}
subnetwork1 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.5])
subnetwork2 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.3])
subnetwork3 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.2]) 
Siths_network <- delete.vertices(network, V(network)[V(network)$role != 'v'])
Heroes_network <- delete.vertices(network, V(network)[V(network)$role != 'h'])
```


**4) Compute the order and size of the network and certain induced subnetworks of interest and draw conclusions about these values. If the network is directed, repeat the operation for in, out and total.**

```{r}
cat("Order of the network:", gorder(network), "\n")
cat("Size of the network:", gsize(network), "\n")
cat("Average degree:", mean(degree(network)), "\n")
```

For the subnetworks, we have:

- Order:
```{r, include=FALSE}
cat("Order of the network that contains the top 50% characters:", gorder(subnetwork1), "\n")
cat("Order of the network that contains the top 70% characters:", gorder(subnetwork2), "\n")
cat("Order of the network that contains the top 80% characters:", gorder(subnetwork3), "\n")
cat("Order of the network that contains the main villains:", gorder(Siths_network), "\n")
cat("Order of the network that contains the heroes:", gorder(Heroes_network), "\n")
```

- Size:
```{r, include=FALSE}
cat("Size of the network that contains the top 50% characters:", gsize(subnetwork1), "\n")
cat("Size of the network that contains the top 70% characters:", gsize(subnetwork2), "\n")
cat("Size of the network that contains the top 80% characters:", gsize(subnetwork3), "\n")
cat("Size of the network that contains the main villains:", gsize(Siths_network), "\n")
cat("Size of the network that contains the heroes:", gsize(Heroes_network), "\n")
```

We observe that as the number of characters included rises (which means an increase in the order), the size of the subnetworks grows as well. Regarding the sith and heroes subnetworks, we observe that while they both have a kind-of similar order, the size is much larger for the heroes

**5) Obtain the degree distribution with and without weights (if any) and comment on the results obtained. Again, if the network is directed, repeat the operation for in, out and total.**

We plot the degree distribution with and without weights:

```{r}
plot(0:max(degree(network)),degree_distribution(network),
     type="h",col="deepskyblue2",lwd=2,
     main="Degree distribution of the Star Wars social network",
     xlab="Degree",ylab="Frequency")
points(0:max(degree(network)),degree_distribution(network),pch=19)

graph_strength_distribution <- function (graph,cumulative=FALSE,...)
{
  if (!is.igraph(graph)) {
    stop("Not a graph object")
  }
  cs <- graph.strength(graph,...)
  hi <- hist(cs,-1:max(cs),plot=FALSE)$density
  if (!cumulative) {
    res <- hi
  }
  else {
    res <- rev(cumsum(rev(hi)))
  }
  res
}

plot(0:max(strength(network)),graph_strength_distribution(network),
     type="h",col="deepskyblue2",lwd=2,
     main="Weighted degree distribution of Star Wars social network",
     xlab="Degree",ylab="Frequency")
points(0:max(strength(network)),graph_strength_distribution(network),pch=20)

```

As expected, the degree distribution is highly skewed. Moreover, even though the weighted distribution contains higher values than the standard degree distribution, he frequency of these high values is very low, and the mass of the distribution is centered in lower values, as the previous one.


**6) Obtain the number of components of the network (weak and strong if the network is directed).**

We first check if the network is connected

```{r}
is_connected(network)
```

Since it is not connected, we look for the number of components

```{r}
unique(components(network)[[1]])
```
We have two components:

```{r}
components(network)[2:3]
```

So, we have a "giant" component that contains 110 nodes and a "small" component that contains 1 node (which references a character that only appears in one scene and is alone).

**7) Compute the diameter with and without weights (if any) and determine the farthest vertices along with the path joining them. Take into account whether the network is directed or not.**

We analyze the distance between nodes and compute the diameter with and without weights:

- Without weights (all weights set to 1):

```{r}
farthest.nodes(network, weights = rep(1,gsize(network)))
get.diameter(network, weights = rep(1,gsize(network)))
```

- With weights:

```{r}
farthest.nodes(network, weights = 1/E(network)$weight)
get.diameter(network, weights = 1/E(network)$weight)
```


**8) Visualize the network. Obtain the graphs that appear on the slides and the code and, very importantly, try to obtain the best possible visualization by using colors and varying all aspects of the graph necessary to do so.**

```{r}
plot.net = function(net, to.edge = c(1,5), to.vertex = c(10,25),
                    vertex.label = V(net)$name.real, cex = 0.9, ...){
  
  plot.igraph(net , edge.color = 'darkgrey', edge.width = rescale(E(net)$value, to = to.edge), vertex.size = rescale(V(net)$value, to = to.vertex), vertex.label = vertex.label, vertex.label.color = "black",
              vertex.label.cex = cex,...)
}
```

We are going to plot the different subnetworks using simple layouts. Starting with the subnetworks based on importance of the characters, we use the circular and star layouts to obtain:

```{r}
par(mfrow=c(1,3))
plot.net(subnetwork1, layout = layout_as_star, main = "50% subnet with star layout")
plot.net(subnetwork2, layout = layout_as_star, main = "70% subnet with star layout")
plot.net(subnetwork3, layout = layout_as_star, main = "80% subnet with star layout")
par(mfrow=c(1,3))
plot.net(subnetwork1, layout = layout_in_circle, main = "80% subnet with circle layout")
plot.net(subnetwork2, layout = layout_in_circle, main = "80% subnet with circle layout")
plot.net(subnetwork3, layout = layout_in_circle, main = "80% subnet with circle layout")
```

For the villains and heroes subnetworks, we get:

```{r}
par(mfrow=c(1,2))
plot.net(Heroes_network, layout = layout_as_star, main = "Heroes subnet with star layout", cex = 0.65)
plot.net(Heroes_network, layout = layout_in_circle, main = "Heroes subnet with star layout", cex = 0.65)
par(mfrow=c(1,2))
plot.net(Siths_network, layout = layout_as_star, main = "Villains subnet with star layout")
plot.net(Siths_network, layout = layout_in_circle, main = "Villains subnet with circle layout")
```

Although these simple layouts work well for the different subnetworks, we need to choose a layout for the whole network. Neither the circle nor the star layout will work for the whole network, since it is too big. 

We can take a general look at the results using the layouts that are based on maximizing energy functions:
 
```{r}
par(mfrow=c(1,2))
#Davidson-Harel layout
plot.net(network, layout = layout_with_dh, cex = 0.5)
#Fruchtermann and Reingold layout
plot.net(network, layout = layout_with_fr, cex = 0.5)
par(mfrow=c(1,2))
#GEM force-directed layout
plot.net(network, layout = layout_with_gem, cex = 0.5)
#Graphopt layout
plot.net(network, layout = layout_with_graphopt, cex = 0.5)
par(mfrow=c(1,2))
#Kamada and Kawai layout
plot.net(network, layout = layout_with_kk, cex = 0.5)
#Multidimensional Scaling layout
plot.net(network, layout = layout_with_mds, cex = 0.5)
```

The results are not very good, and they are more or less the same, with the exception of GEM force-directed layout, which is much worse.

A layout that will allow us to better see the vertex even if we loose some visualization of the edges is the grid layout:

```{r}
plot.net(network, layout = layout_on_grid, cex = 0.25)
```

To better visualize the edges, we can use a chord diagram. It allows us to see the edges very clearly and also highlights those nodes that have a higher importance giving them more space in the outer circle.

```{r, out.width="100%"}
adj_matrix <- as_adjacency_matrix(network,attr = "weight",sparse = T)
chorddiag(as.matrix(adj_matrix),showTicks = FALSE, margin = 40, groupnameFontsize = 4)
```
