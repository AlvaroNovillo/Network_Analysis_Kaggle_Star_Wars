---
title: "Netwok Analysis Project"
author: "Eloy Pérez Gómez, Álvaro Novillo Correas & Jorge Sánchez Polo"
date: "`r Sys.Date()`"
output:
  html_document: default
  word_document: default
  pdf_document: default
subtitle: The Star Wars social network
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# List of packages to install
packages <- c("jsonlite", "igraph", "openxlsx", "remotes", "tidyr", "ggplot2", "dplyr", "scales","corrplot")

# Check if each package is installed and install if not
for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    library(pkg, character.only = TRUE)
  }
}
remotes::install_github("mattflor/chorddiag")
library(chorddiag)
```

## Part 1 
**1) Explain the network including which vertices and edges form it, as well as any additional attributes that may form the network, its vertices and/or its edges.**

We are going to study a Star Wars social network (this network was downloaded from kaggle at <https://www.kaggle.com/datasets/ruchi798/star-wars>). The nodes of this network are the characters of the first seven films and they are connected if they speak with each other in the same scene (this corresponds to the file "starwars-full-interactions-allCharacters-merged.json" from the downloaded data). 

The original network has the following elements:

- The nodes have the following properties:

  - name: Name of the character
  - value: Number of scenes the character appeared in
  - colour: Color in the visualization

- Links represent connections between characters:

  - source: zero-based index of the character that is one end of the link, the order of nodes is the order in which they are listed in the “nodes” element
  - target: zero-based index of the character that is the the other end of the link.
  - value: Number of scenes where the “source character” and “target character” of the link appeared together.

We modify this network and add the following attributes:

- name.real: Contains the name of each character (a copy of the previous attribute "name").
- name: a zero-based index for each character.
- colour: we have modified the color of some of the characters.
- role: we introdue anew attribute that separates the characters in main villains (letter "v"), heroes (letter "h") or background characters (letter "b").

```{r}
# Set the directory path where the JSON files are located
directory_path <- "data" #CHANGE IT WITH YOUR DATA PATH
# Get the list of all JSON files in the directory
json_files <- list.files(path = directory_path, pattern = "*.json", full.names = TRUE)
# Choose the desired JSON file
desired_file <- json_files[22]
# Load the JSON file into R
json_data <- fromJSON(desired_file)
```

Access the nodes and edges (the "nodes.xlsx" file contains the modified version of the nodes)
```{r}
nodes <- read.xlsx("nodes.xlsx")
edges <- json_data$links
```

**2) Describe what the analysis of such a network may be of interest. That is, what are the points that make the network of interest to a general audience.**

Star wars is a franchise most of us grew up watching, either the original trilogy or the later releases. The study of a social network composed of the Star wars characters and their relations may not be as important as some networks related with medicine applications or industry, but it is worth taking a look at, even if it is just for the sake of our childhood memories. 

**3) Make a first graph of the network and describe the main characteristics including whether the network is directed or undirected, if there are subnetworks that may be of interest, if there are loops and/or multi-edges, etc.**

Create a graph from the data
```{r}
network <- graph_from_data_frame(edges, vertices = nodes, directed = FALSE)
E(network)$weight <- edges$value
```

```{r}
# Set the color of each node
V(network)$color <- nodes$colour
# Set the label of each node
V(network)$label <- nodes$name
# Set role attribute of each node
V(network)$role <- nodes$role
V(network)$name = nodes$name.real
```

Plot the graph
```{r}
A = as_adjacency_matrix(network, attr="weight")
plot(network)
```

We have an undirected, weighted network. There are not any loops or multi-edges.

We have several interesting subnetworks. We are going to divide the network in two ways: first using the attributes of the nodes, i.e., considering the most relevant nodes in terms of weights and number of appearances; the second method for obtaining subnetworks is going to be using the information we have from the films. We are going to separate in a network for "heroes" and a network for "villains".

We are going to define three subnetworks depending on the weight of the characters and two subnetworks that contain the main villains and the heroes.

```{r}
subnetwork1 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.5])
subnetwork2 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.3])
subnetwork3 <- subgraph.edges(network, E(network)[E(network)$weight>max(E(network)$weight)*0.2]) 
Siths_network <- delete.vertices(network, V(network)[V(network)$role != 'v'])
Heroes_network <- delete.vertices(network, V(network)[V(network)$role != 'h'])
```


**4) Compute the order and size of the network and certain induced subnetworks of interest and draw conclusions about these values. If the network is directed, repeat the operation for in, out and total.**

To begin the analysis of the network, we first created an adjacency matrix using the as_adjacency_matrix() function from the igraph package in R. The attr argument was set to "weight" to take into account the weighted interactions between the characters. The resulting matrix was then plotted as a heatmap using the corrplot package. Each node was identified with its corresponding character name, which was set as the row and column names of the matrix. This allowed us to visualize the strength and direction of the interactions between characters.

```{r}
adj_matrix <- as_adjacency_matrix(network,attr = "weight",sparse = T)

# Set the row and column names of the matrix to the node names
rownames(adj_matrix) <- nodes$name.real
colnames(adj_matrix) <- nodes$name.real

# Plot the matrix
library(corrplot)
corrplot(as.matrix(adj_matrix),  method = 'shade',is.corr = FALSE,col.lim = c(0,max(max(as.matrix(adj_matrix)))), order = 'AOE', diag = FALSE, tl.cex = 0.3,col = COL1('YlOrBr', 10),tl.col = 'black')
```

Upon inspecting the adjacency matrix, we observed that certain characters such as Darth Vader, Han Solo, and Chewbacca had the highest number of interactions with other characters. These characters had the most weighted links, indicating a significant amount of interaction with other characters in the network.

To further investigate the relationship between the total screenplay of the characters and the number of interactions, we created a barplot showing the top 10 characters with the highest screenplay, allowing us to compare the total screenplay of each character with their corresponding number of interactions. 

```{r}
top_nodes <- nodes[order(nodes$value, decreasing = TRUE),][1:10,]

print(top_nodes)
# Create a barplot using 'name.real' as labels and 'value' as heights
barplot(top_nodes$value, 
        names.arg = top_nodes$name.real, 
        main = "Top Characters with the highest screenplay", 
        ylab = "Screenplay", 
        col = "steelblue",
        las=2)


```

The resulting plot shows that the characters with the highest total screenplay are the main characters of the saga (as expected), and also have a high number of interactions with other characters in the network.

After this initial inspection, the general properties of the network (order, size, and average degree) are:

```{r}
cat("Order of the network:", gorder(network), "\n")
cat("Size of the network:", gsize(network), "\n")
cat("Average degree:", mean(degree(network)), "\n")
```

In the case of the previously defined subnetworks, we have:

- Order:
```{r,echo = FALSE}
cat("Order of the network that contains the top 50% characters:", gorder(subnetwork1), "\n")
cat("Order of the network that contains the top 70% characters:", gorder(subnetwork2), "\n")
cat("Order of the network that contains the top 80% characters:", gorder(subnetwork3), "\n")
cat("Order of the network that contains the main villains:", gorder(Siths_network), "\n")
cat("Order of the network that contains the heroes:", gorder(Heroes_network), "\n")
```

- Size:
```{r,echo = FALSE}
cat("Size of the network that contains the top 50% characters:", gsize(subnetwork1), "\n")
cat("Size of the network that contains the top 70% characters:", gsize(subnetwork2), "\n")
cat("Size of the network that contains the top 80% characters:", gsize(subnetwork3), "\n")
cat("Size of the network that contains the main villains:", gsize(Siths_network), "\n")
cat("Size of the network that contains the heroes:", gsize(Heroes_network), "\n")
```

We observe that as the number of characters included rises (which means an increase in the order), the size of the subnetworks grows as well. Regarding the sith and heroes subnetworks, we observe that while they both have a kind-of similar order, the size is much larger for the heroes

**5) Obtain the degree distribution with and without weights (if any) and comment on the results obtained. Again, if the network is directed, repeat the operation for in, out and total.**

We plot the degree distribution with and without weights:

```{r}
plot(0:max(degree(network)),degree_distribution(network),
     type="h",col="deepskyblue2",lwd=2,
     main="Degree distribution of the Star Wars social network",
     xlab="Degree",ylab="Frequency")
points(0:max(degree(network)),degree_distribution(network),pch=19)

graph_strength_distribution <- function (graph,cumulative=FALSE,...)
{
  if (!is.igraph(graph)) {
    stop("Not a graph object")
  }
  cs <- graph.strength(graph,...)
  hi <- hist(cs,-1:max(cs),plot=FALSE)$density
  if (!cumulative) {
    res <- hi
  }
  else {
    res <- rev(cumsum(rev(hi)))
  }
  res
}

plot(0:max(strength(network)),graph_strength_distribution(network),
     type="h",col="deepskyblue2",lwd=2,
     main="Weighted degree distribution of Star Wars social network",
     xlab="Degree",ylab="Frequency")
points(0:max(strength(network)),graph_strength_distribution(network),pch=20)

```

As expected, the degree distribution is negatively skewed. Moreover, even though the weighted distribution contains higher values than the average degree distribution, the frequency of these high values is very low, and the mass of the distribution is centered in lower values, as the previous one.


**6) Obtain the number of components of the network (weak and strong if the network is directed).**

We first check if the network is connected

```{r}
is_connected(network)
```

Since it is not connected, we look for the number of components

```{r}
unique(components(network)[[1]])
```
We have two components:

```{r}
components(network)[2:3]
```

So, we have a "giant" component that contains 110 nodes and a "small" component that contains 1 node (which references a character that only appears in one scene and is alone).

**7) Compute the diameter with and without weights (if any) and determine the farthest vertices along with the path joining them. Take into account whether the network is directed or not.**

We analyze the distance between nodes and compute the diameter with and without weights:

- Without weights (all weights set to 1):

```{r}
farthest.nodes(network, weights = rep(1,gsize(network)))
get.diameter(network, weights = rep(1,gsize(network)))
```

- With weights:

```{r}
farthest.nodes(network, weights = 1/E(network)$weight)
get.diameter(network, weights = 1/E(network)$weight)
```


**8) Visualize the network. Obtain the graphs that appear on the slides and the code and, very importantly, try to obtain the best possible visualization by using colors and varying all aspects of the graph necessary to do so.**

```{r}
plot.net = function(net, to.edge = c(1,5), to.vertex = c(10,25),
                    vertex.label = V(net)$name.real, cex = 0.9, ...){
  
  plot.igraph(net , edge.color = 'darkgrey', edge.width = rescale(E(net)$value, to = to.edge), vertex.size = rescale(V(net)$value, to = to.vertex), vertex.label = vertex.label, vertex.label.color = "black",
              vertex.label.cex = cex,...)
}
```

We are going to plot the different subnetworks using simple layouts. Starting with the subnetworks based on importance of the characters, we use the circular and star layouts to obtain:

```{r}
par(mfrow=c(1,3))
plot.net(subnetwork1, layout = layout_as_star, main = "50% subnet with star layout")
plot.net(subnetwork2, layout = layout_as_star, main = "70% subnet with star layout")
plot.net(subnetwork3, layout = layout_as_star, main = "80% subnet with star layout")
par(mfrow=c(1,3))
plot.net(subnetwork1, layout = layout_in_circle, main = "80% subnet with circle layout")
plot.net(subnetwork2, layout = layout_in_circle, main = "80% subnet with circle layout")
plot.net(subnetwork3, layout = layout_in_circle, main = "80% subnet with circle layout")
```

For the villains and heroes subnetworks, we get:

```{r}
par(mfrow=c(1,2))
plot.net(Heroes_network, layout = layout_as_star, main = "Heroes subnet with star layout", cex = 0.65)
plot.net(Heroes_network, layout = layout_in_circle, main = "Heroes subnet with star layout", cex = 0.65)
par(mfrow=c(1,2))
plot.net(Siths_network, layout = layout_as_star, main = "Villains subnet with star layout")
plot.net(Siths_network, layout = layout_in_circle, main = "Villains subnet with circle layout")
```

Although these simple layouts work well for the different subnetworks, we need to choose a layout for the whole network. Neither the circle nor the star layout will work for the whole network, since it is too big. 

We can take a general look at the results using the layouts that are based on maximizing energy functions:
 
```{r}
par(mfrow=c(1,2))
#Davidson-Harel layout
plot.net(network, layout = layout_with_dh, cex = 0.5)
#Fruchtermann and Reingold layout
plot.net(network, layout = layout_with_fr, cex = 0.5)
par(mfrow=c(1,2))
#GEM force-directed layout
plot.net(network, layout = layout_with_gem, cex = 0.5)
#Graphopt layout
plot.net(network, layout = layout_with_graphopt, cex = 0.5)
par(mfrow=c(1,2))
#Kamada and Kawai layout
plot.net(network, layout = layout_with_kk, cex = 0.5)
#Multidimensional Scaling layout
plot.net(network, layout = layout_with_mds, cex = 0.5)
```

The results are not very good, and they are more or less the same, with the exception of GEM force-directed layout, which is much worse.

A layout that will allow us to better see the vertex even if we loose some visualization of the edges is the grid layout:

```{r}
plot.net(network, layout = layout_on_grid, cex = 0.25)
```

To better visualize the edges, we can use a chord diagram. It allows us to see the edges very clearly and also highlights those nodes that have a higher importance giving them more space in the outer circle.

```{r, out.width="100%"}
adj_matrix <- as_adjacency_matrix(network,attr = "weight",sparse = T)
chorddiag(as.matrix(adj_matrix),showTicks = FALSE, margin = 40, groupnameFontsize = 4)
```

## Centrality meassures

### Vertex centrality meassures

Let's examine some centrality measures to determine which character in the Star Wars saga has the most significance based on interactions.

To begin, we will sort the edges of our network according to their degree:

```{r}
#Unweighted case
sw_vertices <- sort.int(degree(network),decreasing=TRUE,index.return=TRUE)
sw_vertices$x[1:5]

```

We can observe that Darth Vader and Obi-Wan have the highest degree among the characters in the network.

```{r}
sw_weighted_vertices <- sort.int(strength(network),decreasing=TRUE,index.return=TRUE)
sw_weighted_vertices$x[1:5]
```

However, if we take into consideration the weights in the network (i.e., the number of interactions shared by those two characters), we can see that Han Solo and C-3PO have the most interactions in the series, followed by Chewbacca and R2-D2. It is interesting to note that Obi-Wan is not on this list because he may be connected to many characters, but the number of interactions shared between them is not as significant as the other characters in the franchise.

In addition to degree and strength centrality, another centrality measure that can provide insights into the significance of characters in the Star Wars saga based on their interactions is eigenvector centrality. Eigenvector centrality considers not only the number of connections a character has but also the importance of those connections. It assigns higher centrality scores to characters who are connected to other highly central characters.

Eigenvector centrality is important in network analysis because it accounts for the influence and prominence of the nodes a character is connected to. By incorporating the centrality of neighboring nodes, eigenvector centrality captures the idea that the importance of a character's connections depends on the importance of the characters they are connected to. 

```{r}
# Assuming you have already created the 'network' object

# Compute eigenvector centrality
eigen_centrality <- sort.int(eigen_centrality(network,scale=FALSE,
                                    weights=rep(1,ecount(network)))$vector,
                                    decreasing=TRUE,index.return=TRUE)
eigen_centrality$x[1:10]
```
According to their connections and the influence of those connections, characters such as Darth Vader, Obi-Wan, C-3PO, Han, and R2-D2 exhibit a relatively high degree of eigenvector centrality, indicating their significance in the network.



### Edge centrality meassures
The most common way to assess the centrality of an edge is by using edge betweenness. As previously, we will determine the betweenness centrality both with and without weights.

```{r}
sw_betweenness <- sort.int(betweenness(network,normalized=TRUE,weights=rep(1,ecount(network))),
                               decreasing=TRUE,index.return=TRUE)
sw_betweenness$x[1:5]

```
Based solely on the connections between characters, Darth Vader remains the most central character in the saga, followed by Obi-Wan and C-3PO. Let's examine what happens when we consider the number of interactions between characters, i.e., the edge weights.
```{r}
sw_weighted_betweenness <- sort.int(betweenness(network,normalized=TRUE,weights=1/E(network)$weight),
                                        decreasing=TRUE,index.return=TRUE)
sw_weighted_betweenness$x[1:5]
```
In this instance, Darth Vader still retains the title of the most significant character in the franchise, followed by R2-D2 and Han. It is worth noting that C-3PO and Obi-Wan are also included in the top five once more.

## Density of the network

### Local density
To study the local density of the network, we can examine the number of cliques and the length of the maximal cliques. A clique is a subset of nodes in a network where each node is directly connected to every other node in the subset. The length of a clique refers to the number of nodes within that clique.
```{r}

# Compute the number of cliques and the length of the maximal cliques
cliques <- cliques(network)
num_cliques <- length(cliques)
max_clique_length <- max(sapply(cliques, length))

# Count the number of cliques by length
clique_lengths <- table(sapply(cliques, length))

# Count the number of maximal cliques by length
maximal_cliques <- maximal.cliques(network)
maximal_lengths <- table(sapply(maximal_cliques, length))

# Print the results
cat("Cliques:\n")
cat("Length of cliques:", paste(names(clique_lengths), collapse = " "), "\n")
cat("Number of cliques:", paste(clique_lengths, collapse = " "), "\n\n")

cat("Maximal cliques:\n")
cat("Length of maximal cliques:", paste(names(maximal_lengths), collapse = " "), "\n")
cat("Number of maximal cliques:", paste(maximal_lengths, collapse = " "), "\n")

```

The results show that there are cliques of various lengths, ranging from length 1 to length 9. The number of cliques also varies, with the highest number observed for cliques of length 4.

Maximal cliques are the largest possible cliques within a network, meaning that they cannot be extended by adding another node without violating the condition of every node being connected to every other node. The results indicate that there are maximal cliques of different lengths, ranging from length 1 to length 9. The highest number of maximal cliques is observed for cliques of length 3.

Based on these findings, we can conclude that the network exhibits a mixture of local density levels. The presence of cliques of various lengths suggests that there are cohesive groups within the network, where nodes have strong connections with each other. The higher number of cliques of length 4 and the higher number of maximal cliques of length 3 indicate that there are subsets of nodes that form tightly connected clusters. Even though, of the 444 cliques of length 3, only 22 of them are maximal. This indicates that the network is sparse, i.e., it is not specially dense. 

This suggests that there are both highly connected subgroups and areas with relatively lower connectivity within the network, as expected when we previously inspected the former subnetworks of different characters based on their relationship and strength of the link. 

Lets take a deeper look into the largest cliques of the network:

```{r}
largest_cliques(network)
```

