---
title: "Netwok Analysis Project"
subtitle: "The Star Wars social netowrk"
author: "Eloy Pérez Gómez, Álvaro Novillo Correas & Jorge Sánchez Polo"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(jsonlite)
library(igraph)
```


**1) Explain the network including which vertices and edges form it, as well as any additional attributes that may form the network, its vertices and/or its edges.**

We are going to study a Star Wars social network (this network was downloaded from kaggle at <https://www.kaggle.com/datasets/ruchi798/star-wars>). The nodes of this network are the characters of the first seven films and they are connected if they speak with each other in the same scene (this corresponds to the file "starwars-full-interactions-allCharacters-merged.json" from the downloaded data). 

The original network has the following elements:

- The nodes have the following properties:

  - name: Name of the character
  - value: Number of scenes the character appeared in
  - colour: Colour in the visualization

- Links represent connections between characters:

  - source: zero-based index of the character that is one end of the link, the order of nodes is the order in which they are listed in the “nodes” element
  - target: zero-based index of the character that is the the other end of the link.
  - value: Number of scenes where the “source character” and “target character” of the link appeared together.

We modify this network and add the following attributes:

- name.real: Contains the name of each character (a copy of the previous attribute "name").
- name: a zero-based index for each character.

```{r}
# Set the directory path where the JSON files are located
directory_path <- "data" #CHANGE IT WITH YOUR DATA PATH
# Get the list of all JSON files in the directory
json_files <- list.files(path = directory_path, pattern = "*.json", full.names = TRUE)
# Display the list of JSON files
print(json_files)
# Choose the desired JSON file
desired_file <- json_files[22]
# Load the JSON file into R
json_data <- fromJSON(desired_file)
```

Access the nodes and edges
```{r}
nodes <- json_data$nodes
edges <- json_data$links

nodes$name.real = nodes$name
nodes$name = c(0:(length(nodes$name)-1))
```

**2) Describe what the analysis of such a network may be of interest. That is, what are the points that make the network of interest to a general audience.**

Star wars is a franchise most of us grew up watching, either the original trilogy or the later releases. The study of a social network composed of the Star wars characters and their relations may not be as important as some networks related with medicine applications or industry, but it is worth taking a look at, even if it is just for the sake of our childhood memories. 

**3) Make a first graph of the network and describe the main characteristics including whether the network is directed or undirected, if there are subnetworks that may be of interest, if there are loops and/or multi-edges, etc.**

Create a graph from the data
```{r}
network <- graph_from_data_frame(edges, vertices = nodes, directed = FALSE)
E(network)$weight <- edges$value
```


```{r}
# Set the color of each node
V(network)$color <- nodes$colour
# Set the label of each node
V(network)$label <- nodes$name
```

Plot the graph
```{r}
A = as_adjacency_matrix(network, attr="weight")
plot(network)
```

We have an undirected, weighted network. We have several interesting subnetworks. We are going to divide the network in two ways: first using the attributes of the nodes, i.e., considering the most relevant nodes in terms of weights and number of appearances; the second method for obtaining subnetworks is going to be using the information we have from the films. We are going to separate in a network for "heroes" and a netqork for "villains"

**4) Compute the order and size of the network and certain induced subnetworks of interest and draw conclusions about these values. If the network is directed, repeat the operation for in, out and total.**

**5) Obtain the degree distribution with and without weights (if any) and comment on the results obtained. Again, if the network is directed, repeat the operation for in, out and total.**

**6) Obtain the number of components of the network (weak and strong if the network is directed).**

**7) Compute the diameter with and without weights (if any) and determine the farthest vertices along with the path joining them. Take into account whether the network is directed or not.**

**8) Visualize the network. Obtain the graphs that appear on the slides and the code and, very importantly, try to obtain the best possible visualization by using colors and varying all aspects of the graph necessary to do so.**

##Davidson-Harel layout 
```{r}
plot(subnetwork1, layout = layout_with_dh, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```

##Fruchtermann and Reingold layout
```{r}
plot(subnetwork1, layout = layout_with_fr, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```

##GEM force-directed layout
```{r}
plot(subnetwork1, layout = layout_with_gem, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```

##Graphopt layout
```{r}
plot(subnetwork1, layout = layout_with_graphopt, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```

##Kamada and Kawai layout
```{r}
plot(subnetwork1, layout = layout_with_kk, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```

##Multidimensional Scaling layout
```{r}
plot(subnetwork1, layout = layout_with_mds, edge.color = 'darkgrey',layout = m2,edge.width = (edges$value - min(edges$value))/(max(edges$value) - min(edges$value))*(7-2) + 2 , vertex.size=(nodes$value - min(nodes$value))/(max(nodes$value) - min(nodes$value))*(20-5) + 7)
```
